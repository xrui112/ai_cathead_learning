根据如描述说明，帮我编写一款简单的AI对话页面。
        1. 基于vue3编写美观的UI。
        2. 点击新建聊天，会创建一个新的加入左侧的聊天列表
        3. 聊天列表可以点击展开选择。
        4. 选择的聊天，在对话列表中，可以点击删除或者重命名。
        5. 输入内容，点击发送按钮和使用快捷键，调用服务端流式请求接口，前端渲染展示。
        6. 遵守大多数VUE3项目的习惯 API接口统一封装到一个地方 方便调用
        7. 从 响应结果 result.output.content 获取，应答的文本展示。注意 content 可能为空。
        8. 从 响应结构 result.metadata.finishReason = STOP 获取，结束标识。
        9. 注意整体样式的简洁美观。

        接口信息如下

        流式GET请求接口，由 SpringBoot Spring AI 框架实现，如下；

/**
 * curl http://localhost:8090/api/v1/ollama/generate_stream?model=deepseek-r1:1.5b&message=1+1
 */
@RequestMapping(value = "generate_stream", method = RequestMethod.GET)
@Override
public Flux<ChatResponse> generateStream(@RequestParam String model, @RequestParam String message) {
        return chatClient.stream(new Prompt(
        message,
        OllamaOptions.create()
        .withModel(model)
        ));
        }

        流式GET应答数据，数组中的一条对象；

        [
        {
        "result": {
        "output": {
        "messageType": "ASSISTANT",
        "properties": {
        "id": "chatcmpl-B3HPw95SsqmhoWeJ8azGLxK1Vf4At",
        "role": "ASSISTANT",
        "finishReason": ""
        },
        "content": "1",
        "media": []
        },
        "metadata": {
        "finishReason": null,
        "contentFilterMetadata": null
        }
        }
        }
        ]




根据下面的接口实现 文件上传构建RAG的功能:
- ragTag 为知识库名称
- files 为知识库文件，支持，md、txt、sql 文件类型上传。
@RequestMapping(value = "file/upload",method = RequestMethod.POST,headers =  "content-type=multipart/form-data")
    @Override
    public Response<String> uploadFile(@RequestParam String ragTag,@RequestParam("file") List<MultipartFile> files) {
        log.info("上传知识库开始 {}",ragTag);
        for(MultipartFile file:files){
            TikaDocumentReader tkReader=new TikaDocumentReader(file.getResource());
            List<Document> documents=tkReader.get();
            List<Document> documentsSpilit=tokenTextSplitter.apply(documents);

            documents.forEach(doc->doc.getMetadata().put("knowledge",ragTag));

            documentsSpilit.forEach(doc -> doc.getMetadata().put("knowledge",ragTag) );

            pgVectorStore.accept(documentsSpilit);

            RList<String> ragTags= redissonClient.getList("ragTag");
            if(!ragTags.contains(ragTag)){
                ragTags.add(ragTag);
            }
        }

        log.info("上传完成 {}",ragTag);
        return Response.<String>builder()
                .code("0000")
                .info("调用成功")
                .build();
    }

对于构建了知识库之后的问答 应该调用接口:
@RequestMapping(value = "generate_stream_rag",method = RequestMethod.GET)
    @Override
    public Flux<ChatResponse> generateStreamRag(@RequestParam String model,@RequestParam String ragTag,@RequestParam String message){
        String SYSTEM_PROMPT = """
                Use the information from the DOCUMENTS section to provide accurate answers but act as if you knew this information innately.
                If unsure, simply state that you don't know.
                Another thing you need to note is that your reply must be in Chinese!
                DOCUMENTS:
                    {documents}
                """;
        SearchRequest request=SearchRequest.builder()
                .query(message)
                .topK(5)
                .filterExpression("knowledge == "+ragTag)
                .build();

        List<Document> documents=pgVectorStore.similaritySearch(request);

        String docMerge=documents.stream().map(Document::getText).collect(Collectors.joining());

        Message ms=new SystemPromptTemplate(SYSTEM_PROMPT).createMessage(Map.of("documents", docMerge));

        List<Message> messages=new ArrayList<>();
        messages.add(new UserMessage(message));
        messages.add(ms);
        return ollamaChatModel.stream(new Prompt(
                messages,
                OllamaOptions.builder()
                        .model(model)
                        .build()
        ));
    }